### The foundations of the C++ type system.

C++ is ugly, not just because of its identity conflict, like in this fictional dialog:

>Imperative? yeah, but not all the time... Procedural? yeah, I can do but don't really like it... Ah! Object Oriented? well... yes, but even though I support all of it, even multiple inheritance of implementations I don't really like it either... Hell! what about Functional? I am sorry, I like it, but I don't know how to provide good support for it, I would have to break the others even more... Running out of options here, do you support Declarative? well, I have excellent type deductions, but no inference whatsoever... I am "Generic", but to program in a generic way you also have to program in all the others...

but also because the theory behind many of its succeses was incipient, that is, immature, while adopted, and the whole reason why the new ideas were adopted was precisely because of its identity conflict gave room for different approaches to co-exists, be tried.  It reminds me of the political system of the United States, abundant in good ideas, but with glaring design defficiencies, for example, the way in which a political party can sabotage nominations to the judiciary to block the other party that holds the executive branch.

Being a practicioner of C++ involves accepting that frequently the complexities of reality will break abstractions, this is not really bad, because reality will be dealt with, as opposed to ignored behind beautiful abstractions, but the code will be messy -- reality is messy.

#### Generic Programming capital insight

Again, programming in C++ is not easy to a large degree because of inherent complexity.  It is clearly more difficult to express generic software than concrete software.  What do we have to express genericity in C++? we have the pioneering work done by Alexander Stepanov into illustrating what may be his insight or discovery:  Data structures are algebraic structures.  If algorithms are reinterpreted into consumers of algebraic structures, there is a well developed body of knowledge to identify and capitalize on the generic properties.  To this insight, we can add support from the language in the form of the ability to express parametric types (templates), excellent type deduction (via overload resolution) and a fairly robust type system that allows the composition of types, including generic types, to arbitrary complexities.  That and a bunch of accidental complexity thrown in because the language was not *designed* to support these things.  One example of the accidental complexity is the lack of modularity, which will be described later.

A more pernicious defficiency is their free-format nature.  In 1998, C++ had to be extended to the maximum of what the standardization committee could go to accommodate the minimal features needed for a decent STL; and they succeeded, but although the STL itself could be coded, it was in practice nearly impossible to help users get meaningful errors when small misuse of templates happened, or check that implementations honored the specification, or avoid pitfalls of unexpected argument dependent lookup (Koening lookup, or ADL, overload resolution) that led to very unexpected code; furthermore, any effort on helping with these three things hit another wall:  The compilation times were unacceptably long, templates exacerbated every reason why compilation times were long and made it worse; the compilers at the time were merely barely able to accept valid code, not at all to compile efficiently, nor to leverage all the opportunities for optimizations that the extra richness of information that using templates provided; if some tricks were employed to further restrict the templates (to help the user, etc), then they would compound the problems.

